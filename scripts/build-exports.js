// @ts-nocheck

// NOTE: The @ts-nocheck above tells TypeScript not to check this file for various problems

'use strict';

const {
  promises: { readdir, readFile, writeFile }
} = require('fs');
const { posix: path } = require('path');

const packagesDir = path.join(__dirname, '..', 'packages');

const nestedExports = [path.join('src', 'components')];

const analyzeExports = (/** @type {string} */ code) => {
  let def = false;
  let named = false;

  // Literal default export.
  if (/\bexport\s+default\b/.test(code)) def = true;

  // Literal named export.
  if (/\bexport\s+(?:var|const|let|function|\*)/.test(code)) named = true;

  if (!def && !named) {
    // Gather exports from groups.
    const groups = [...code.matchAll(/export\s+\{([^}]+?)\}/gs)];

    // Split into array of exports.
    const exs = groups.flatMap(([, group]) => group.split(',').map(s => s.trim()));

    // Check for default exports.
    def = exs.some(exp => exp === 'default' || exp.endsWith('as default'));

    // Check for named exports.
    named = exs.some(exp => exp !== 'default' && !exp.endsWith('as default'));
  }

  return { default: def, named };
};

/**
 *
 * @param {string} pkg
 * @param {string} indexPath
 * @param {string} dir
 * @returns {String[]}
 */
const exportsForFile = async (pkg, indexPath, dir) => {
  try {
    const code = await readFile(path.join(packagesDir, pkg, dir, 'index.ts'), 'utf-8');

    const base = path.basename(dir);

    const exs = analyzeExports(code);

    const rtn = [];

    const importPath = path.relative(indexPath, dir);

    if (exs.default) rtn.push(`export { default as ${base} } from './${importPath}';`);
    if (exs.named) rtn.push(`export * from './${importPath}';`);

    return rtn;
  } catch (err) {
    if (err.code !== 'ENOENT') throw err;
  }

  return [];
};

/** @returns {Promise<string[]>} */

/**
 * @param {string} pkg
 * @param {string} indexPath
 * @param {string} dir
 * @returns {Promise<string[]>}
 */
const exportsForDir = async (pkg, indexPath, dir) => {
  const files = await readdir(path.join(packagesDir, pkg, dir), {
    withFileTypes: true
  });

  const hasInit = !!files.find(f => f.name === 'init.ts' && !f.isDirectory());

  const dirs = files.filter(f => f.isDirectory()).sort(({ name: nameA }, { name: nameB }) => nameA.localeCompare(nameB, 'en-US'));

  return (hasInit ? ["import './init';\n"] : []).concat(
    (
      await Promise.all(
        dirs.map(({ name }) =>
          nestedExports.includes(path.join(dir, name))
            ? exportsForDir(pkg, indexPath, path.join(dir, name))
            : exportsForFile(pkg, indexPath, path.join(dir, name))
        )
      )
    ).flat()
  );
};

const createIndex = async (/** @type {string} */ pkg, /** @type {string} */ dir) => {
  return writeFile(
    path.join(packagesDir, pkg, dir, 'index.ts'),
    `/* eslint-disable import/export */\n// This file is autogenerated. Any changes will be overwritten.\n${(await exportsForDir(pkg, dir, dir))
      .flat()
      .join('\n')}\n`
  );
};

const readDirsForCode = async () => {
  readdir(packagesDir, { withFileTypes: true }).then(async dirs => {
    dirs.map(dir => {
      console.log(`readdir: dir.name: ${dir.name}`);
    });
    const arr = await Promise.all(
      dirs.flatMap(dir => {
        /* JEA mod - was cosmos- below - don't process react-sdk-overrides  */
        dir.isDirectory() && !dir.name.includes('react-sdk-overrides') && /^react-sdk-(?!demos)/.test(dir.name) ? [createIndex(dir.name, 'src')] : [];
      })
    );
    console.log(`${arr.length === 1 ? 'Index' : 'Indices'} generated.`);
  });
};

const processSdkExports = async () => {
  await readDirsForCode();
};

processSdkExports();
